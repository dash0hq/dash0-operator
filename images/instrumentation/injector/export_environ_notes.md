Notes About `__environ`, `_environ` & `environ`
===============================================

This file contains research notes about how different C libraries and runtimes interact with environment variables, in
particular how they initialize their internal view of the process environment at startup.

glibc
-----

In glibc, the variable `__environ` (and its aliases `_environ` and `environ`, see
https://sourceware.org/git/?p=glibc.git;a=blob;f=posix/environ.c) is the global pointer to the environment variable
array for a process. It is a pointer to a list of pointers, each of which points to a null-terminated string. Hence the
type `char** environ`. Its initialization involves cooperation between the kernel, the program loader, and the C runtime
startup code.
* The environment is passed on the stack by the kernel: When a new program is executed (via the kernel's `execve`
  system call), the kernel arranges the process's initial stack to include the argument vector (argv) and the
  environment vector (envp).
  Both are arrays of pointers to strings, with the environment array terminated by a NULL pointer.
* glibc startup Code Sets `__environ`: The program's entry point is typically the `_start` symbol, which is not
  `main()`, but a lower-level entry in the C runtime.
  This startup code extracts the pointers to argc, argv, and envp from the stack.
  The glibc startup code then sets the global variable `__environ` (and its aliases) to point to the environment array
  (`envp`).
  This happens in `csu/libc-start.c`, see
  https://sourceware.org/git/?p=glibc.git;a=blob;f=csu/libc-start.c;h=6f3d52e223d8f32dfecf1364c4665e54c6170f28;hb=HEAD#l246
* `/proc/self/environ` is not involved (see below, section
  "Relationship Between /proc/self/environ, envp and __environ")

Initially, the environment array points to memory on the stack, but as soon as the process modifies its environment
(e.g., via `setenv` or `putenv`), libc copies the environment to heap-allocated memory.
This allows for dynamic resizing and mutability of the environment.
If the environment is modified, glibc reallocates it on the heap and updates `__environ` accordingly.

See also: https://unix.stackexchange.com/questions/496940/how-is-the-c-library-able-to-access-environment-variables

musl libc
---------

Basically same as in glibc, the Kernel hands over the `envp` pointer and that is used as `__environ` initially.

In musl libc, the `__environ` variable is initialized before the user's `main` function is called.
This process is tightly coupled with how the program receives its arguments and environment from the kernel.
When a new program is executed, the kernel passes three things on the stack:
* the argument count (`argc`),
* the argument vector (`argv`),
* and the environment pointer (`envp`).

Musl libc's startup code, specifically in the function `__libc_start_main`, is responsible for setting up the C runtime
before calling main.
Inside __libc_start_main, musl sets the global `__environ` pointer to point to the environment vector received from the
kernel.
This is done by assigning the `envp` argument (which is a `char **`) to the global `__environ` variable.

Relevant musl source code:
* https://git.musl-libc.org/cgit/musl/tree/src/env/__libc_start_main.c?h=v1.2.5#n26

If the environment is changed at runtime (e.g., via putenv or setenv), musl manages updates to `__environ` accordingly,
but the initial setup is always from the kernel's stack data.

Relationship Between /proc/self/environ, envp and __environ
-----------------------------------------------------------

`envp` and `/proc/self/environ` both represent the environment variables of a process in Linux, but they do so in
different contexts and with important distinctions.

`envp` (environment pointer) is a parameter that is passed to the startup routines and the main function in C programs,
that is, `int main(int argc, char *argv[], char *envp[])` or similar.
It is a null-terminated array of strings, where each string is an environment variable in the format NAME=value.
When a process is started, the kernel passes the environment to the process via `envp` which is set up from the
environment provided to the `execve` system call.

The virtual file `/proc/self/environ` also represents the kernel's view of the environment.
It contains the environment of the current process as a sequence of null-separated strings, each representing an
environment variable in the same NAME=value format.
This file reflects the environment as it was when the process was started, i.e., what was passed to the process at exec
time.

The content is generated by the kernel on-demand by reading the process's memory, and is not updated if the process
changes its environment after startup using functions like setenv() or unsetenv().

At process start, `envp` and `/proc/self/environ` represent the same are equivalent in the sense that both reflecting
the environment passed at exec time.

After process startup, changes made to the environment via library calls (e.g., setenv, unsetenv) are reflected in
envp/environ, but not necessarily in /proc/self/environ, since the kernel does not track these changes in user space.

`/proc/self/environ` is primarily useful for inspecting the initial environment of a process from outside the process,
while `__environ`/`envp is used internally by the process to access and manipulate its environment.

Node.js
-------

Environment variables are handled in the vendored copy of `libuv` that is used by Node.js:
* Set up the process.env proxy: https://github.com/nodejs/node/blob/v24.2.0/src/node_realm.cc#L368-L375
* `CreateEnvProxyTemplate`: https://github.com/nodejs/node/blob/v24.2.0/src/node_env_var.cc#L573-L593
* `EnvGetter`: https://github.com/nodejs/node/blob/v24.2.0/src/node_env_var.cc#L427-L447, 
  `EnvQuery`: https://github.com/nodejs/node/blob/v24.2.0/src/node_env_var.cc#L485-L500, &
  `EnvEnumerator`: https://github.com/nodejs/node/blob/v24.2.0/src/node_env_var.cc#L194-L218
* Delegation to `libuv` functions `uv_os_getenv` and `uv_os_environ`:
  https://github.com/nodejs/node/blob/v24.2.0/src/node_env_var.cc#L110,
  https://github.com/nodejs/node/blob/v24.2.0/src/node_env_var.cc#L164, &
  https://github.com/nodejs/node/blob/v24.2.0/src/node_env_var.cc#L200
* `libuv`s function `uv_os_getenv` relies on `getenv` internally:
  https://github.com/nodejs/node/blob/v24.2.0/deps/uv/src/unix/core.c#L1510-L1533, which is imported from `stdlib.h`
  (https://github.com/nodejs/node/blob/v24.2.0/deps/uv/src/unix/core.c#L27), so it is ultimately the glibc/musl
  implementation.
* `libuv`'s function `uv_os_environ` relies on the dependency to the `environ` symbol internally, which is declared
  as an external dependency here: https://github.com/nodejs/node/blob/v24.2.0/deps/uv/src/unix/core.c#L67

