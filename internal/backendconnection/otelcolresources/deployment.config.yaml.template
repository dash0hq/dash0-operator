exporters:
{{- if .DevelopmentMode }}
  debug: {}
{{- end }}
{{- range $i, $exporter := .Exporters }}
  {{ $exporter.Name }}:
    endpoint: "{{ $exporter.Endpoint }}"
{{ if $exporter.Insecure }}
    tls:
      insecure: true
{{ end }}
{{- if $exporter.Headers }}
    headers:
{{- range $i, $header := $exporter.Headers }}
      "{{ $header.Name }}": "{{ $header.Value }}"
{{- end }}
{{- end }}
{{- if $exporter.Encoding }}
    encoding: "{{ $exporter.Encoding }}"
{{- end }}
{{- end }}

extensions:
  health_check:
    endpoint: "{{ .SelfIpReference }}:13133"

processors:
  batch: {}

  k8sattributes:
    extract:
      metadata:
      - k8s.cluster.uid
      - k8s.cronjob.name
      # - k8s.cronjob.uid actually not implemented although advertised in k8sattributes' readme.
      - k8s.daemonset.name
      - k8s.daemonset.uid
      - k8s.deployment.name
      - k8s.deployment.uid
      - k8s.job.name
      - k8s.job.uid
      - k8s.namespace.name
      - k8s.node.name
      - k8s.pod.hostname
      - k8s.pod.ip
      - k8s.pod.name
      - k8s.pod.start_time
      - k8s.pod.uid
      - k8s.replicaset.name
      - k8s.replicaset.uid
      - k8s.statefulset.name
      - k8s.statefulset.uid
      labels:
      - key: dash0.com/instrumented
        tag_name: dash0.monitoring.instrumented
        from: pod
    passthrough: false
    pod_association:
    - sources:
      - from: resource_attribute
        name: k8s.pod.ip
    - sources:
      - from: resource_attribute
        name: k8s.pod.uid

  {{- if .ClusterName }}
  resource:
    attributes:
      - key: k8s.cluster.name
        value: "{{ .ClusterName }}"
        action: insert
  {{- end }}

  {{- if .NamespaceOttlFilter }}
  filter/metrics_only_monitored_namespaces:
    metrics:
      metric:
        - {{ .NamespaceOttlFilter }}
  {{- end }}

  # Remove noisy replicaset metrics (by default, Kubernetes keeps a history of 10 replicasets for each deployment,
  # collecting metrics about all of them leads to a lot of metrics with no value). Removing zero-value datapoints
  # makes sure the backend knows about the actual active replicaset (with desired > 0).
  filter/drop-replicaset-metrics-zero-value:
    error_mode: ignore
    metrics:
      datapoint:
      - metric.name == "k8s.replicaset.available" and value_int == 0
      - metric.name == "k8s.replicaset.desired" and value_int == 0

  memory_limiter:
    check_interval: 5s
    limit_percentage: 80
    spike_limit_percentage: 25

receivers:
  k8s_cluster:
    metrics:
      k8s.container.restarts:
        enabled: false
      k8s.namespace.phase:
        enabled: false

service:
  extensions:
  - health_check

  pipelines:

    metrics/downstream:
      receivers:
      - k8s_cluster
      processors:
      - k8sattributes
      {{- if .ClusterName }}
      - resource
      {{- end }}
      {{- if .NamespaceOttlFilter }}
      - filter/metrics_only_monitored_namespaces
      {{- end }}
      - filter/drop-replicaset-metrics-zero-value
      - memory_limiter
      - batch
      exporters:
      {{- if .DevelopmentMode }}
      - debug
      {{- end }}
      {{- range $i, $exporter := .Exporters }}
      - {{ $exporter.Name }}
      {{- end }}

  telemetry:
    {{- if .ClusterName }}
    resource:
      "k8s.cluster.name": "{{- .ClusterName }}"
    {{- end }}
    metrics:
      readers:
        - pull:
            exporter:
              prometheus:
                host: "{{ .SelfIpReference }}"
                port: 8888
