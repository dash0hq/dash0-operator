extensions:
  health_check:
    endpoint: "{{ .SelfIpReference }}:13133"


{{- if .TelemetryFilters }}
{{- if .TelemetryFilterFlags.HasMetricFilter }}
connectors:
  # Routing configuration for per-namespace telemetry filters. The signal is routed from the main pipeline to the custom
  # filter pipeline, if rules are configured for the namespace in question, and then returned back to the main pipeline.
  # (Think aux send & aux return in an audio mixing console.)
  # connector for routing metrics telemetry to per-namespace filter pipelines
  routing/metrics/customfilter/send:
    default_pipelines:
    - metrics/downstream
    table:
      {{- range $i, $f := .TelemetryFilters }}
      - context: resource
        condition: 'attributes["k8s.namespace.name"] == "{{ $f.Namespace }}"'
        pipelines:
        - metrics/filter/{{ $f.Namespace }}
      {{- end }}
  # connector for routing metrics telemetry back from per-namespace filter pipelines into the main export pipeline
  forward/metrics/customfilter/return: {}
{{- end }}
{{- end }}


receivers:
  k8s_cluster:
    metrics:
      k8s.container.restarts:
        enabled: false
      k8s.namespace.phase:
        enabled: false


processors:
{{- if .SendBatchMaxSize }}
  batch:
    send_batch_max_size: {{ .SendBatchMaxSize }}
{{- else }}
  batch: {}
{{- end }}

  k8sattributes:
    extract:
      metadata:
      - k8s.cluster.uid
      - k8s.cronjob.name
      # - k8s.cronjob.uid actually not implemented although advertised in k8sattributes' readme.
      - k8s.daemonset.name
      - k8s.daemonset.uid
      - k8s.deployment.name
      - k8s.deployment.uid
      - k8s.job.name
      - k8s.job.uid
      - k8s.namespace.name
      - k8s.node.name
      - k8s.pod.hostname
      - k8s.pod.ip
      - k8s.pod.name
      - k8s.pod.start_time
      - k8s.pod.uid
      - k8s.replicaset.name
      - k8s.replicaset.uid
      - k8s.statefulset.name
      - k8s.statefulset.uid
      labels:
      - key: dash0.com/instrumented
        tag_name: dash0.monitoring.instrumented
        from: pod
    passthrough: false
    pod_association:
    - sources:
      - from: resource_attribute
        name: k8s.pod.ip
    - sources:
      - from: resource_attribute
        name: k8s.pod.uid

  {{- if .ClusterName }}
  resource/clustername:
    attributes:
      - key: k8s.cluster.name
        value: "{{ .ClusterName }}"
        action: insert
  {{- end }}

  {{- if .NamespaceOttlFilter }}
  filter/metrics/only_monitored_namespaces:
    metrics:
      metric:
        - {{ .NamespaceOttlFilter }}
  {{- end }}

  # Remove noisy replicaset metrics (by default, Kubernetes keeps a history of 10 replicasets for each deployment,
  # collecting metrics about all of them leads to a lot of metrics with no value). Removing zero-value datapoints
  # makes sure the backend knows about the actual active replicaset (with desired > 0).
  filter/drop-replicaset-metrics-zero-value:
    error_mode: ignore
    metrics:
      datapoint:
      - metric.name == "k8s.replicaset.available" and value_int == 0
      - metric.name == "k8s.replicaset.desired" and value_int == 0

  {{- if .TelemetryFilters }}
  {{- if .TelemetryFilterFlags.HasMetricFilter }}
  {{- range $i, $f := .TelemetryFilters }}
  filter/metrics/{{ $f.Namespace }}:
    error_mode: ignore
    metrics:
      {{- if $f.Metrics.MetricFilter.Conditions }}
      metric:
      {{- range $j, $condition := $f.Metrics.MetricFilter.Conditions }}
      - '{{ $condition }}'
      {{- end }}
      {{- end }}
      {{- if $f.Metrics.DataPointFilter.Conditions }}
      datapoint:
      {{- range $j, $condition := $f.Metrics.DataPointFilter.Conditions }}
      - '{{ $condition }}'
      {{- end }}
      {{- end }}
  {{- end }}
  {{- end }}
  {{- end }}{{/* if .TelemetryFilters */}}

  memory_limiter:
    check_interval: 5s
    limit_percentage: 80
    spike_limit_percentage: 25


exporters:
{{- if .DebugVerbosityDetailed }}
  debug:
    verbosity: detailed
{{ else if .DevelopmentMode }}
  debug: {}
{{- end }}
{{- range $i, $exporter := .Exporters }}
  {{ $exporter.Name }}:
    endpoint: "{{ $exporter.Endpoint }}"
{{- if $exporter.Insecure }}
    tls:
      insecure: true
{{ end }}
{{- if $exporter.Headers }}
    headers:
{{- range $i, $header := $exporter.Headers }}
      "{{ $header.Name }}": "{{ $header.Value }}"
{{- end }}
{{- end }}
{{- if $exporter.Encoding }}
    encoding: "{{ $exporter.Encoding }}"
{{- end }}
{{- end }}


service:
  extensions:
  - health_check

  pipelines:

    metrics/collect:
      receivers:
      - k8s_cluster
      processors:
      - k8sattributes
      {{- if .ClusterName }}
      - resource/clustername
      {{- end }}
      {{- if .NamespaceOttlFilter }}
      - filter/metrics/only_monitored_namespaces
      {{- end }}
      - filter/drop-replicaset-metrics-zero-value
      - memory_limiter
      - batch
      exporters:
      - routing/metrics/customfilter/send

    {{- if (and .TelemetryFilters .TelemetryFilterFlags.HasMetricFilter) }}
    {{- range $i, $f := .TelemetryFilters }}
    # TODO only iterate over namespaces that have a metrics filter
    metrics/filter/{{ $f.Namespace }}:
      receivers:
      - routing/metrics/customfilter/send
      processors:
      - filter/metrics/{{ $f.Namespace }}
      exporters:
      - forward/metrics/customfilter/return
    {{- end }}
    {{- end }}

    metrics/downstream:
      receivers:
      {{- if (and .TelemetryFilters .TelemetryFilterFlags.HasMetricFilter) }}
      - forward/metrics/customfilter/return
      {{- end }}
      # The routing/metrics/customfilter/send receiver needs to be here because this pipeline is declared as the
      # "default_pipelines" pipeline for the routing connector, i.e. for namespaces without a metrics filter. It also is
      # the only connection from metrics/collect if no metrics filters are defined whatsoever.
      - routing/metrics/customfilter/send
      exporters:
      {{- if (or .DevelopmentMode .DebugVerbosityDetailed) }}
      - debug
      {{- end }}
      {{- range $i, $exporter := .Exporters }}
      - {{ $exporter.Name }}
      {{- end }}

  telemetry:
    {{- if .ClusterName }}
    resource:
      "k8s.cluster.name": "{{- .ClusterName }}"
    {{- end }}
    metrics:
      readers:
        - pull:
            exporter:
              prometheus:
                host: "{{ .SelfIpReference }}"
                port: 8888
