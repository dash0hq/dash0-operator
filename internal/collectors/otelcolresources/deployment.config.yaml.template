extensions:
  health_check:
    endpoint: "{{ .SelfIpReference }}:13133"
  {{- if .EnableProfExtension }}
  pprof: {}
  {{- end }}


receivers:
  k8s_cluster:
    metrics:
      k8s.container.status.reason:
        enabled: true
      k8s.container.status.state:
        enabled: true
      k8s.namespace.phase:
        enabled: false
  k8s_events:
    namespaces:
{{- range $i, $namespace := .NamespacesWithMonitoring }}
    - '{{ $namespace }}'
{{- end }}

processors:
{{- if .SendBatchMaxSize }}
  batch:
    send_batch_max_size: {{ .SendBatchMaxSize }}
{{- else }}
  batch: {}
{{- end }}

  k8sattributes:
    extract:
      {{- if .DisableReplicasetInformer }}
      deployment_name_from_replicaset: true
      {{- end }}
      metadata:
      - k8s.cluster.uid
      - k8s.cronjob.name
      - k8s.cronjob.uid
      - k8s.daemonset.name
      - k8s.daemonset.uid
      - k8s.deployment.name
      {{- if not .DisableReplicasetInformer }}
      - k8s.deployment.uid
      {{- end }}
      - k8s.job.name
      - k8s.job.uid
      - k8s.namespace.name
      - k8s.node.name
      - k8s.pod.hostname
      - k8s.pod.ip
      - k8s.pod.name
      - k8s.pod.start_time
      - k8s.pod.uid
      - k8s.replicaset.name
      - k8s.replicaset.uid
      - k8s.statefulset.name
      - k8s.statefulset.uid
      # The following two work only if k8s.pod.uid and k8s.container.name are set
      - container.image.name
      - container.image.tag
{{- if .CollectPodLabelsAndAnnotationsEnabled }}
      labels:
        - tag_name: k8s.pod.label.$$1
          key_regex: (.*)
          from: pod
      annotations:
        - tag_name: k8s.pod.annotation.$$1
          key_regex: (.*)
          from: pod
{{- end }}
    passthrough: false
    pod_association:
    - sources:
      - from: resource_attribute
        name: k8s.pod.ip
    - sources:
      - from: resource_attribute
        name: k8s.pod.uid

  # Limit resource attributes to a reasonable maximum length. This is particularly important when transforming
  # Kubernetes pod annotations to resource attributes, which can hold up to 256KB of data.
  transform/resources:
    error_mode: ignore
    trace_statements:
      - context: resource
      - statements:
        - truncate_all(resource.attributes, 2048)
    metric_statements:
      - context: resource
      - statements:
        - truncate_all(resource.attributes, 2048)
    log_statements:
      - context: resource
      - statements:
        - truncate_all(resource.attributes, 2048)

  transform/k8s_events:
    error_mode: ignore
    log_statements:
      ##### Pod Specific Transformations ####
      - context: log
        conditions:
          - resource.attributes["k8s.object.kind"] == "Pod" and resource.attributes["k8s.object.uid"] != nil and log.attributes["k8s.event.name"] != nil
        statements:
          # Set EventName to "k8s.event" this also marks the log record as a handled event
          - set(log.event_name, "k8s.event")

          # Set k8s.pod.name in resource attributes
          - set(resource.attributes["k8s.pod.name"], resource.attributes["k8s.object.name"]) where resource.attributes["k8s.object.name"] != nil

          # Set k8s.pod.uid in resource attributes
          - set(resource.attributes["k8s.pod.uid"], resource.attributes["k8s.object.uid"]) where resource.attributes["k8s.object.uid"] != nil

      ##### DaemonSet Specific Transformations ####
      - context: log
        conditions:
          - resource.attributes["k8s.object.kind"] == "DaemonSet" and resource.attributes["k8s.object.uid"] != nil and log.attributes["k8s.event.name"] != nil
        statements:
          # Set EventName to "k8s.event" this also marks the log record as a handled event
          - set(log.event_name, "k8s.event")

          # Set k8s.daemonset.name in resource attributes
          - set(resource.attributes["k8s.daemonset.name"], resource.attributes["k8s.object.name"]) where resource.attributes["k8s.object.name"] != nil

          # Set k8s.daemonset.uid in resource attributes
          - set(resource.attributes["k8s.daemonset.uid"], resource.attributes["k8s.object.uid"]) where resource.attributes["k8s.object.uid"] != nil

      ##### Deployment Specific Transformations ####
      - context: log
        conditions:
          - resource.attributes["k8s.object.kind"] == "Deployment" and resource.attributes["k8s.object.uid"] != nil and log.attributes["k8s.event.name"] != nil
        statements:
          # Set EventName to "k8s.event" this also marks the log record as a handled event
          - set(log.event_name, "k8s.event")

          # Set k8s.deployment.name in resource attributes
          - set(resource.attributes["k8s.deployment.name"], resource.attributes["k8s.object.name"]) where resource.attributes["k8s.object.name"] != nil

          # Set k8s.deployment.uid in resource attributes
          - set(resource.attributes["k8s.deployment.uid"], resource.attributes["k8s.object.uid"]) where resource.attributes["k8s.object.uid"] != nil

      ##### ReplicaSet Specific Transformations ####
      - context: log
        conditions:
          - resource.attributes["k8s.object.kind"] == "ReplicaSet" and resource.attributes["k8s.object.uid"] != nil and log.attributes["k8s.event.name"] != nil
        statements:
          # Set EventName to "k8s.event" this also marks the log record as a handled event
          - set(log.event_name, "k8s.event")

          # Set k8s.replicaset.name in resource attributes
          - set(resource.attributes["k8s.replicaset.name"], resource.attributes["k8s.object.name"]) where resource.attributes["k8s.object.name"] != nil

          # Set k8s.replicaset.uid in resource attributes
          - set(resource.attributes["k8s.replicaset.uid"], resource.attributes["k8s.object.uid"]) where resource.attributes["k8s.object.uid"] != nil

      ##### StatefulSet Specific Transformations ####
      - context: log
        conditions:
          - resource.attributes["k8s.object.kind"] == "StatefulSet" and resource.attributes["k8s.object.uid"] != nil and log.attributes["k8s.event.name"] != nil
        statements:
          # Set EventName to "k8s.event" this also marks the log record as a handled event
          - set(log.event_name, "k8s.event")

          # Set k8s.statefulset.name in resource attributes
          - set(resource.attributes["k8s.statefulset.name"], resource.attributes["k8s.object.name"]) where resource.attributes["k8s.object.name"] != nil

          # Set k8s.statefulset.uid in resource attributes
          - set(resource.attributes["k8s.statefulset.uid"], resource.attributes["k8s.object.uid"]) where resource.attributes["k8s.object.uid"] != nil

      ##### Job Specific Transformations ####
      - context: log
        conditions:
          - resource.attributes["k8s.object.kind"] == "Job" and resource.attributes["k8s.object.uid"] != nil and log.attributes["k8s.event.name"] != nil
        statements:
          # Set EventName to "k8s.event" this also marks the log record as a handled event
          - set(log.event_name, "k8s.event")

          # Set k8s.job.name in resource attributes
          - set(resource.attributes["k8s.job.name"], resource.attributes["k8s.object.name"]) where resource.attributes["k8s.object.name"] != nil

          # Set k8s.job.uid in resource attributes
          - set(resource.attributes["k8s.job.uid"], resource.attributes["k8s.object.uid"]) where resource.attributes["k8s.object.uid"] != nil

      ##### CronJob Specific Transformations ####
      - context: log
        conditions:
          - resource.attributes["k8s.object.kind"] == "CronJob" and resource.attributes["k8s.object.uid"] != nil and log.attributes["k8s.event.name"] != nil
        statements:
          # Set EventName to "k8s.event" this also marks the log record as a handled event
          - set(log.event_name, "k8s.event")

          # Set k8s.cronjob.name in resource attributes
          - set(resource.attributes["k8s.cronjob.name"], resource.attributes["k8s.object.name"]) where resource.attributes["k8s.object.name"] != nil

          # Set k8s.cronjob.uid in resource attributes
          - set(resource.attributes["k8s.cronjob.uid"], resource.attributes["k8s.object.uid"]) where resource.attributes["k8s.object.uid"] != nil

      ##### Common Transformations ####
      - context: log
        conditions:
          - log.event_name == "k8s.event" and resource.attributes["k8s.object.uid"] != nil and log.attributes["k8s.event.name"] != nil
        statements:
          # Move k8s.namespace.name from attributes to resource attributes
          - set(resource.attributes["k8s.namespace.name"], log.attributes["k8s.namespace.name"]) where log.attributes["k8s.namespace.name"] != nil
          - delete_key(attributes, "k8s.namespace.name") where attributes["k8s.namespace.name"] != nil

          # Move k8s.object.fieldpath from resource attributes to attributes
          - set(log.attributes["k8s.object.fieldpath"], resource.attributes["k8s.object.fieldpath"]) where resource.attributes["k8s.object.fieldpath"] != nil
          - delete_key(resource.attributes, "k8s.object.fieldpath")

          # Move k8s.object.resource_version from resource attributes to attributes
          - set(attributes["k8s.object.resource_version"], resource.attributes["k8s.object.resource_version"]) where resource.attributes["k8s.object.resource_version"] != nil
          - delete_key(resource.attributes, "k8s.object.resource_version")

          # Set timestamp to k8s.event.start_time if available
          - set(log.cache["event_start_time"], UnixNano(Time(log.attributes["k8s.event.start_time"], "%Y-%m-%dT%H:%M:%SZ"))) where log.attributes["k8s.event.start_time"] != nil
          - set(log.time_unix_nano, log.cache["event_start_time"]) where cache["event_start_time"] > 0

          ## Cleanup ##
          # Remove k8s.object.kind and k8s.object.api_version from resource attributes
          - delete_key(resource.attributes, "k8s.object.kind")
          - delete_key(resource.attributes, "k8s.object.api_version")

          # Remove previously copied attributes
          - delete_key(resource.attributes, "k8s.object.name")
          - delete_key(resource.attributes, "k8s.object.uid")

  {{- if .ClusterName }}
  resource/clustername:
    attributes:
      - key: k8s.cluster.name
        value: "{{ .ClusterName }}"
        action: insert
  {{- end }}

{{ if .NamespaceOttlFilter }}
  filter/metrics/only_monitored_namespaces:
    metrics:
      metric:
        - {{ .NamespaceOttlFilter }}
{{- end }}

  # Remove noisy replicaset metrics (by default, Kubernetes keeps a history of 10 replicasets for each deployment,
  # collecting metrics about all of them leads to a lot of metrics with no value). Removing zero-value datapoints
  # makes sure the backend knows about the actual active replicaset (with desired > 0).
  filter/drop-replicaset-metrics-zero-value:
    error_mode: ignore
    metrics:
      datapoint:
      - metric.name == "k8s.replicaset.available" and value_int == 0
      - metric.name == "k8s.replicaset.desired" and value_int == 0

{{ if .CustomFilters.HasMetricFilters }}
  filter/metrics/custom_telemetry_filter:
    error_mode: ignore
    metrics:
      {{- if .CustomFilters.MetricConditions }}
      metric:
        {{- range $i, $condition := .CustomFilters.MetricConditions }}
        - '{{ $condition }}'
        {{- end }}
      {{- end }}
      {{- if .CustomFilters.DataPointConditions }}
      datapoint:
        {{- range $i, $condition := .CustomFilters.DataPointConditions }}
        - '{{ $condition }}'
        {{- end }}
      {{- end }}
{{- end }}

{{ if .CustomTransforms.HasMetricTransforms }}
  transform/metrics/custom_telemetry_transform:
    error_mode: {{ .CustomTransforms.GlobalErrorMode }}
    metric_statements:
      {{- range $i, $group := .CustomTransforms.MetricGroups }}
      - statements:
          {{- range $i, $statement := $group.Statements }}
          - '{{ $statement }}'
          {{- end }}
      {{- if $group.Conditions }}
        conditions:
          {{- range $i, $condition := $group.Conditions }}
          - '{{ $condition }}'
          {{- end }}
      {{- end }}
      {{- if $group.ErrorMode }}
        error_mode: {{ $group.ErrorMode }}
      {{- end }}
      {{- if $group.Context }}
        context: {{ $group.Context }}
      {{- end }}
      {{- end }}
{{- end }}

  memory_limiter:
    check_interval: 1s
    limit_percentage: 80
    spike_limit_percentage: 25


exporters:
{{- if .DebugVerbosityDetailed }}
  debug:
    verbosity: detailed
{{ else if .DevelopmentMode }}
  debug: {}
{{- end }}
{{- range $i, $exporter := .Exporters }}
  {{ $exporter.Name }}:
    endpoint: "{{ $exporter.Endpoint }}"
    {{- if $exporter.Insecure }}
    tls:
      insecure: true
    {{- else if $exporter.InsecureSkipVerify }}
    tls:
      insecure_skip_verify: true
    {{- end }}
{{- if $exporter.Headers }}
    headers:
{{- range $i, $header := $exporter.Headers }}
      "{{ $header.Name }}": "{{ $header.Value }}"
{{- end }}
{{- end }}
{{- if $exporter.Encoding }}
    encoding: "{{ $exporter.Encoding }}"
{{- end }}
{{- end }}


service:
  extensions:
  - health_check
  {{- if .EnableProfExtension }}
  - pprof
  {{- end }}

  pipelines:

    metrics/downstream:
      receivers:
      - k8s_cluster
      processors:
      - memory_limiter
      - k8sattributes
      {{- if .ClusterName }}
      - resource/clustername
      {{- end }}
      {{- if .NamespaceOttlFilter }}
      - filter/metrics/only_monitored_namespaces
      {{- end }}
      - filter/drop-replicaset-metrics-zero-value
      {{- if .CustomFilters.HasMetricFilters }}
      - filter/metrics/custom_telemetry_filter
      {{- end }}
      - batch
      {{- if .CustomTransforms.HasMetricTransforms }}
      - transform/metrics/custom_telemetry_transform
      {{- end }}
      - transform/resources
      exporters:
      {{- if (or .DevelopmentMode .DebugVerbosityDetailed) }}
      - debug
      {{- end }}
      {{- range $i, $exporter := .Exporters }}
      - {{ $exporter.Name }}
      {{- end }}

    logs/k8sevents:
      receivers:
      - k8s_events
      processors:
      - transform/k8s_events
      - k8sattributes
      {{- if .ClusterName }}
      - resource/clustername
      {{- end }}
      - transform/resources
      - memory_limiter
      - batch
      exporters:
      {{- if (or .DevelopmentMode .DebugVerbosityDetailed) }}
      - debug
      {{- end }}
      {{- range $i, $exporter := .Exporters }}
      - {{ $exporter.Name }}
      {{- end }}

{{- if .InternalTelemetryEnabled }}
  telemetry:
    resource:
      "k8s.cluster.uid": "{{- .PseudoClusterUid }}"
      {{- if .ClusterName }}
      "k8s.cluster.name": "{{- .ClusterName }}"
      {{- end }}
      "k8s.node.name": "${env:K8S_NODE_NAME}"
      "k8s.namespace.name": "${env:DASH0_OPERATOR_NAMESPACE}"
      "k8s.deployment.uid": "${env:K8S_DEPLOYMENT_UID}"
      "k8s.deployment.name": "${env:K8S_DEPLOYMENT_NAME}"
      "k8s.pod.uid": "${env:K8S_POD_UID}"
      "k8s.pod.name": "${env:K8S_POD_NAME}"
      "k8s.container.name": "opentelemetry-collector"

{{- if .SelfMonitoringMetricsConfig }}
{{- .SelfMonitoringMetricsConfig }}
{{- end }}
{{- if .SelfMonitoringLogsConfig }}
{{- .SelfMonitoringLogsConfig }}
{{- end }}
{{- end }}
